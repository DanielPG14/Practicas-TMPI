import cv2
import numpy as np

#Cargar imagen
imagen = cv2.imread('Tareas/tar.jpg')
if imagen is None:
    raise ValueError("No se pudo cargar la imagen. Verifica la ruta.")

imagen_gris = cv2.cvtColor(imagen, cv2.COLOR_BGR2GRAY)

#Transformaciones Geométricas
imagen_escalada = cv2.resize(imagen, (300, 300))
M = cv2.getRotationMatrix2D((imagen.shape[1]//2, imagen.shape[0]//2), 45, 1)
imagen_rotada = cv2.warpAffine(imagen, M, (imagen.shape[1], imagen.shape[0]))
imagen_reflejada = cv2.flip(imagen, 1)
imagen_trasladada = cv2.warpAffine(imagen, np.float32([[1, 0, 50], [0, 1, 50]]), (imagen.shape[1], imagen.shape[0]))

#Transformación de perspectiva
puntos_origen = np.float32([[0, 0], [imagen.shape[1]-1, 0], [0, imagen.shape[0]-1], [imagen.shape[1]-1, imagen.shape[0]-1]])
puntos_destino = np.float32([[0, 0], [300, 0], [0, 300], [300, 300]])
M_perspectiva = cv2.getPerspectiveTransform(puntos_origen, puntos_destino)
imagen_perspectiva = cv2.warpPerspective(imagen, M_perspectiva, (imagen.shape[1], imagen.shape[0]))

#Segmentación
_, segmentada_binaria = cv2.threshold(imagen_gris, 127, 255, cv2.THRESH_BINARY)
segmentada_canny = cv2.Canny(imagen_gris, 100, 200)
segmentada_adaptativa = cv2.adaptiveThreshold(imagen_gris, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 11, 2)
segmentada_otsu = cv2.threshold(imagen_gris, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)[1]
segmentada_kmeans = cv2.kmeans(imagen_gris.reshape(-1, 1).astype(np.float32), 2, None, (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 10, 1.0), 10, cv2.KMEANS_RANDOM_CENTERS)[1].reshape(imagen_gris.shape)

#Umbralización
_, umbral_simple = cv2.threshold(imagen_gris, 127, 255, cv2.THRESH_BINARY)
umbral_adaptativo = cv2.adaptiveThreshold(imagen_gris, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2)
umbral_otsu = cv2.threshold(imagen_gris, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)[1]
umbral_invertido = cv2.bitwise_not(umbral_simple)
umbral_truncado = cv2.threshold(imagen_gris, 127, 255, cv2.THRESH_TRUNC)[1]

#Binarización
binarizada_otsu = cv2.threshold(imagen_gris, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)[1]
binarizada_invertida = cv2.bitwise_not(binarizada_otsu)
binarizada_adaptativa = cv2.adaptiveThreshold(imagen_gris, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 11, 2)
binarizada_gauss = cv2.adaptiveThreshold(imagen_gris, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2)
binarizada_media = cv2.threshold(imagen_gris, np.mean(imagen_gris), 255, cv2.THRESH_BINARY)[1]

#Mostrar resultados
cv2.imshow('Escalada', imagen_escalada)
cv2.imshow('Rotada', imagen_rotada)
cv2.imshow('Reflejada', imagen_reflejada)
cv2.imshow('Trasladada', imagen_trasladada)
cv2.imshow('Perspectiva', imagen_perspectiva)
cv2.imshow('Segmentada Binaria', segmentada_binaria)
cv2.imshow('Segmentada Canny', segmentada_canny)
cv2.imshow('Segmentada Adaptativa', segmentada_adaptativa)
cv2.imshow('Segmentada Otsu', segmentada_otsu)
cv2.imshow('Segmentada K-Means', segmentada_kmeans.astype(np.uint8))
cv2.imshow('Umbral Simple', umbral_simple)
cv2.imshow('Umbral Adaptativo', umbral_adaptativo)
cv2.imshow('Umbral Otsu', umbral_otsu)
cv2.imshow('Umbral Invertido', umbral_invertido)
cv2.imshow('Umbral Truncado', umbral_truncado)
cv2.imshow('Binarizada Otsu', binarizada_otsu)
cv2.imshow('Binarizada Invertida', binarizada_invertida)
cv2.imshow('Binarizada Adaptativa', binarizada_adaptativa)
cv2.imshow('Binarizada Gauss', binarizada_gauss)
cv2.imshow('Binarizada Media', binarizada_media)

cv2.waitKey(0)
cv2.destroyAllWindows()
